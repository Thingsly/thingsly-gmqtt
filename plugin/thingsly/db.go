package thingsly

import (
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/spf13/viper"
	"gopkg.in/redis.v5"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

var redisCache *redis.Client
var db *gorm.DB

type Device struct {
	ID             string     `gorm:"column:id;primaryKey;comment:Id" json:"id"` // Primary key
	Name           *string    `gorm:"column:name;comment:Device name" json:"name"`
	DeviceType     int16      `gorm:"column:device_type;not null;default:1;comment:Device type (1 - Direct, 2 - Gateway, 3 - Sub-device). Default is direct." json:"device_type"`
	Voucher        string     `gorm:"column:voucher;not null;comment:Credential, auto-generated by default" json:"voucher"`
	TenantID       string     `gorm:"column:tenant_id;not null;comment:Tenant ID (foreign key, restrict on delete)" json:"tenant_id"`
	IsEnabled      string     `gorm:"column:is_enabled;not null;comment:Status: 'enabled' or 'disabled'. Default is 'disabled', changes to 'enabled' after activation." json:"is_enabled"`
	ActivateFlag   string     `gorm:"column:activate_flag;not null;comment:Activation flag: 'inactive' or 'active'" json:"activate_flag"`
	CreatedAt      *time.Time `gorm:"column:created_at;comment:Created time" json:"created_at"`
	UpdateAt       *time.Time `gorm:"column:update_at;comment:Updated time" json:"update_at"`
	DeviceNumber   string     `gorm:"column:device_number;not null;comment:Device number. Defaults to token if not provided." json:"device_number"`
	ProductID      *string    `gorm:"column:product_id;comment:Product ID (foreign key, restrict on delete)" json:"product_id"`
	ParentID       *string    `gorm:"column:parent_id;comment:Gateway ID (for sub-devices)" json:"parent_id"`
	Protocol       *string    `gorm:"column:protocol;comment:Communication protocol" json:"protocol"`
	Lable          *string    `gorm:"column:lable;comment:Tag, comma-separated" json:"lable"`
	Location       *string    `gorm:"column:location;comment:Geographical location" json:"location"`
	SubDeviceAddr  *string    `gorm:"column:sub_device_addr;comment:Sub-device address" json:"sub_device_addr"`
	CurrentVersion *string    `gorm:"column:current_version;comment:Current firmware version" json:"current_version"`
	AdditionalInfo *string    `gorm:"column:additional_info;default:{};comment:Additional info (e.g., thresholds, images)" json:"additional_info"`
	ProtocolConfig *string    `gorm:"column:protocol_config;default:{};comment:Protocol configuration in form format" json:"protocol_config"`
	Remark1        *string    `gorm:"column:remark1" json:"remark1"`
	Remark2        *string    `gorm:"column:remark2" json:"remark2"`
	Remark3        *string    `gorm:"column:remark3" json:"remark3"`
	DeviceConfigID *string    `gorm:"column:device_config_id;comment:Device configuration ID" json:"device_config_id"`
	BatchNumber    *string    `gorm:"column:batch_number;comment:Batch number" json:"batch_number"`
}

// Specify table name
func (Device) TableName() string {
	return "devices"
}

func createRedisClient() *redis.Client {
	redisHost := viper.GetString("db.redis.conn")
	dataBase := viper.GetInt("db.redis.db_num")
	password := viper.GetString("db.redis.password")

	log.Println("Connecting to Redis...")
	client := redis.NewClient(&redis.Options{
		Addr:         redisHost,
		Password:     password,
		DB:           dataBase,
		ReadTimeout:  2 * time.Minute,
		WriteTimeout: 1 * time.Minute,
		PoolTimeout:  2 * time.Minute,
		IdleTimeout:  10 * time.Minute,
		PoolSize:     1000,
	})

	// Ping Redis to confirm connection
	if _, err := client.Ping().Result(); err != nil {
		log.Println("Failed to connect to Redis:", err)
		panic(err)
	}

	log.Println("Connected to Redis successfully.")
	return client
}

func createPgClient() *gorm.DB {
	psqladdr := viper.GetString("db.psql.psqladdr")
	psqlport := viper.GetInt("db.psql.psqlport")
	psqluser := viper.GetString("db.psql.psqluser")
	psqlpass := viper.GetString("db.psql.psqlpass")
	psqldb := viper.GetString("db.psql.psqldb")

	connectionString := fmt.Sprintf(
		"user=%s password=%s dbname=%s host=%s port=%d sslmode=disable",
		psqluser, psqlpass, psqldb, psqladdr, psqlport,
	)

	log.Println("Connecting to PostgreSQL...")
	db, err := gorm.Open(postgres.Open(connectionString), &gorm.Config{})
	if err != nil {
		panic(err)
	}

	log.Println("Connected to PostgreSQL successfully.")
	return db
}

func Init() {
	redisCache = createRedisClient()
	db = createPgClient()
}

func SetStr(key, value string, time time.Duration) (err error) {
	err = redisCache.Set(key, value, time).Err()
	if err != nil {
		return err
	}
	return err
}

func GetStr(key string) (value string, err error) {
	v, err := redisCache.Get(key).Result()
	if err != nil {
		return "", err
	}
	return v, nil
}

func DelKey(key string) (err error) {
	err = redisCache.Del(key).Err()
	return err
}

func SetNX(key, value string, expiration time.Duration) (ok bool, err error) {
	ok, err = redisCache.SetNX(key, value, expiration).Result()
	return
}

func DelNX(key string) (err error) {
	err = redisCache.Del(key).Err()
	return
}

// SetRedisForJsondata serializes any object into JSON and stores it in Redis
func SetRedisForJsondata(key string, value interface{}, expiration time.Duration) error {
	jsonData, err := json.Marshal(value)
	if err != nil {
		return err
	}
	return redisCache.Set(key, jsonData, expiration).Err()
}

// GetRedisForJsondata retrieves a JSON object from Redis and deserializes it into the provided destination
func GetRedisForJsondata(key string, dest interface{}) error {
	val, err := redisCache.Get(key).Result()
	if err != nil {
		return err
	}
	return json.Unmarshal([]byte(val), dest)
}

// GetDeviceByVoucher retrieves device information based on a voucher token.
// It first attempts to retrieve the device ID from Redis.
// If not found, it falls back to querying the database, then caches both the ID and the device data.
func GetDeviceByVoucher(voucher string) (*Device, error) {
	var device Device

	deviceId, _ := GetStr(voucher)
	Log.Debug("Cached device ID: " + deviceId)

	if deviceId == "" {
		// Not in Redis, query from database
		result := db.Model(&Device{}).Where("voucher = ?", voucher).First(&device)
		if result.Error != nil {
			Log.Info(result.Error.Error())
			return nil, result.Error
		}

		// Cache the device ID for the voucher
		if err := SetStr(voucher, device.ID, 0); err != nil {
			return nil, err
		}

		// Cache the device details using the device ID
		if err := SetRedisForJsondata(device.ID, device, 0); err != nil {
			return nil, err
		}
	} else {
		// Device ID found in Redis, get full device info
		d, err := GetDeviceById(deviceId)
		if err != nil {
			return nil, err
		}
		device = *d
	}

	return &device, nil
}

// GetDeviceById retrieves device information using the device ID.
// It first checks Redis cache; if not found, it queries the database and updates the cache.
func GetDeviceById(deviceId string) (*Device, error) {
	var device Device

	// Attempt to get from Redis (optional: could be added here for efficiency)
	// err := GetRedisForJsondata(deviceId, &device)
	// if err == nil {
	//     return &device, nil
	// }

	// Fallback to database
	result := db.Model(&Device{}).Where("id = ?", deviceId).First(&device)
	if result.Error != nil {
		return nil, result.Error
	}

	// Cache the device info
	if err := SetRedisForJsondata(deviceId, device, 0); err != nil {
		return nil, err
	}

	return &device, nil
}

// GetDeviceByToken retrieves device information using the token.
type UserPub struct {
	Attribute string `json:"attribute"`
	Event     string `json:"event"`
}
type UserSub struct {
	Attribute string `json:"attribute"`
	Commands  string `json:"commands"`
}
type UserTopic struct {
	UserPub UserPub `json:"user_pub"`
	UserSub UserSub `json:"user_sub"`
}

// func GetUserTopicByToken(token string) (*UserTopic, error) {
// 	var userTopic UserTopic
// 	device, err := GetDeviceByToken(token)
// 	if err != nil {
// 		return nil, err
// 	}
// 	if device.AdditionalInfo == "" {
// 		return nil, fmt.Errorf("empty")
// 	}
// 	var additionalInfo map[string]interface{}
// 	err = json.Unmarshal([]byte(device.AdditionalInfo), &additionalInfo)
// 	if err != nil {
// 		return nil, err
// 	}
// 	if _, ok := additionalInfo["user_topic"]; !ok {
// 		return nil, fmt.Errorf("empty")
// 	}
// 	userTopicJson, err := json.Marshal(additionalInfo["user_topic"])
// 	if err != nil {
// 		return nil, err
// 	}
// 	err = json.Unmarshal(userTopicJson, &userTopic)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return &userTopic, nil
// }
